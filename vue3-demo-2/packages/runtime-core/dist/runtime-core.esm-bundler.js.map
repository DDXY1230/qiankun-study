{"version":3,"file":"runtime-core.esm-bundler.js","sources":["../../shared/src/index.ts","../src/vnode.ts","../src/apiCreateApp.ts","../src/component.ts","../src/renderer.ts"],"sourcesContent":["export const isObject = (value) => typeof value == 'object' && value !== null; // 判断是否是对象\nexport const extend = Object.assign\nexport const isArray = Array.isArray\nexport const isFunction = value => typeof value == 'function'\nexport const isNumber = value => typeof value == 'number'\nexport const isString = value => typeof value == 'string'\nexport const isIntegerKey = key => parseInt(key) + '' === key\n\nlet hasOwnProperty = Object.prototype.hasOwnProperty\nexport const hasOwn = (target, key) => hasOwnProperty.call(target, key)\nexport const hasChange = (oldValue, value) => oldValue !== value\nexport * from './shapeFlags'","import { ShapeFlags,isString,isObject,isArray } from \"@vue/shared\"\n\nexport function createVNode(type, props,children = null) {\n  // 可以根据type来区分组件还是普通元素\n\n  // 根据type来区分 是元素还是组件\n  const ShapeFlag = isString(type) ? \n  ShapeFlags.ELEMENT : isObject(type) ? \n  ShapeFlags.STATEFUL_COMPONENT : 0\n  const vnode = {\n    __v_isVnode: true,\n    type,\n    props,\n    children,\n    component: null,\n    el: null,\n    key: props && props.key,\n    ShapeFlag\n  }\n  normalizeChildren(vnode,children)\n  return vnode\n}\nfunction normalizeChildren(vnode, children) {\n  let type = 0\n  if(children == null) {\n    // 不对儿子进行处理\n  }else if(isArray(children)){\n    type = ShapeFlags.ARRAY_CHILDREN\n  }else {\n    type = ShapeFlags.TEXT_CHILDREN\n  }\n  vnode.ShapeFlags |= type // 判断自己的类型和儿子的类型\n}","import { createVNode } from \"./vnode\"\n\nexport function createAppAPI(render) {\n  return function createApp(rootComponent, rootProps) {\n    const app = {\n      _props: rootProps,\n      _component: rootComponent,\n      _container: null,\n      mount(container) { // 挂载到哪里去\n        // console.log('渲染的参数', container, rootComponent, rootProps, rendererOption)\n        // let vnode = {}\n        // render(vnode, container)\n\n        // 1.根据组件创建虚拟节点\n        // 2.将虚拟节点和容器获取到后调用render方法进行渲染\n\n        // 虚拟节点  调render函数\n        const vnode = createVNode(rootComponent, rootProps)\n        console.log('vnode===》', vnode)\n        render(vnode,container)\n        app._container = container\n\n\n\n      }\n    }\n    return app\n  }\n}","import { ShapeFlags } from '@vue/shared';\nexport const createComponentInstance = function (vnode) {\n  const instance = {// 组件实例\n    vnode,\n    type: vnode.type,\n    props: {},\n    attrs: {},\n    slots: {},\n    ctx: {},\n    setupState: {},\n    render: null,\n    isMounted: false\n  }\n  instance.ctx = { _: instance }\n  return instance\n}\nexport const setupComponent = function (instance) {\n    const { props,children } = instance.vnode;\n    // 根据props解析出props和attrs, 将其放到instance\n    instance.props = props // iniProps\n    instance.children = children // 插槽的解析\n    // 需要先看一下,当前组件是不是有状态的组件\n    console.log('instance',instance)\n    let isStateful = instance.vnode.ShapeFlag & ShapeFlags.STATEFUL_COMPONENT\n    console.log('isStateful', isStateful)\n    if(isStateful) {\n      // 一个带状态的组件\n      // 调用当前实例setup的方法, 用setup的返回值填充setupState和对应的render方法\n      setupStatefulComponent(instance)\n    }\n}\nfunction setupStatefulComponent(instance) {\n  // 1.代理 传递给render函数的参数\n\n  // 2.获取组件的类型\n  let Component = instance.type \n  let {setup} = Component \n  setup()\n}","import { createAppAPI } from \"./apiCreateApp\"\nimport { ShapeFlags } from \"@vue/shared\"\nimport {createComponentInstance,setupComponent } from './component'\n\n\nexport function createRenderer(rendererOption) {// 告诉core  怎么渲染\n  const setupRenderEffect = () => {\n\n  }\n  const mountComponent = (initialVnode, container) => {// 挂载组件\n    console.log('初始化', initialVnode, container)\n    // 组件的渲染流程 最核心的是调用setup 拿到返回值,获取render函数返回的结果进行渲染\n    // 1.先有实例\n    const instance = initialVnode.component = createComponentInstance(initialVnode)\n    // 2.需要的数据解析到实例上面去\n    setupComponent(instance)\n    // 3.创建一个effect让render函数执行\n    setupRenderEffect()\n\n  }\n  const processComponent = (n1, n2, container) => {\n    if (n1 == null) {// 组件没有上次的虚拟节点 初始化过程\n      mountComponent(n2, container)\n    } else { // 组件更新\n\n    }\n  }\n  const patch = (n1, n2, container) => {\n    // 针对不同类型做初始化操作\n    const { ShapeFlag } = n2;\n    if (ShapeFlag & ShapeFlags.ELEMENT) {\n      console.log('n2是元素')\n    } else if (ShapeFlag & ShapeFlags.STATEFUL_COMPONENT) {\n      console.log('n2是一个组件')\n      processComponent(n1, n2, container)\n    }\n  }\n  const render = (vnode, container) => {\n    // 核心 core  根据不同的虚拟节点创建对应的真实元素\n\n    patch(null, vnode, container)\n  }\n  return {\n    createApp: createAppAPI(render)\n  }\n}"],"names":[],"mappings":"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"}