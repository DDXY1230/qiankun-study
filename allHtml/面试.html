<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Document</title>
</head>

<body>
  <p>
    1.开放性问题: 谈谈项目中的亮点/难点?
    单点登录
    权限的多维度管控
    产品解决策略
    ...
    重点讲这些:
    性能优化
    webpack层面
    页面渲染层面
    大文件传输处理
    插件组件封装

  </p>
  <p>
    2.性能优化 敏捷化平台 造轮子
    项目协调,工作安排,人员管理,代码review
    不要只做cv
    CRP:关键渲染原理
  </p>
  <p>
    3.从输入url地址到看到页面,中间经历了啥?
    答案:
    1. URL解析
    TCP 传输通道
    http/https: 传输协议
    FTP: 传输一些大文件
    登录信息认证
    域名:服务器地址
    端口号: 0-65535
    请求资源文件名
    问号后面是参数

    http: 80
    https: 443
    解析完地址,进行缓存检查,

    缓存:缓存一般有两种:强缓存/协商缓存,一般先检测是否有强缓存,如果有强缓存且为失效走强缓存
    如果过期失效了或者没有强缓存就去检测协商缓存,如果协商缓也没有就去获取新数据
    缓存位置:内存缓存/硬盘缓存
    ECStack 栈内存 内存缓存关闭之后就没了,硬盘会存的久一些
    html一般不做强缓存

    <br>
    URL编码解码: encodeURI/decodeURI
    对地址栏参数的编码解码: encodeURIComponent/decodeURIComponent
    还有escape / unescape 这个用的少,因为后端没有,交互的时候后段有时候无法解码

    还有一个问题自己搜一搜: URI/URL/URN的区别?
    性能优化有一条: DNS请求,一个页面中尽可能少的域名,,
    但是实际项目不会这么做,实际项目会从很多服务器拿资源,多服务器集群共享,因为服务器的抗压能力不一样
    为了资源的合理利用、服务器的抗压能力、提高http并发....

    DNS预获取

    最后TCP三次握手
    在客户端与服务器端建立连接,建立稳定的传输通道
    为什么是三次不是两次?
    tcp作为一种可靠的传输控制协议,其核心思想:既要保证数据可靠传输,又要提高传输的效率,三次刚刚好


    UDP 传输快但是可能会数据丢失

    关闭的时候是四次挥手

  </p>

  <p>
    单例模式: 相互的独立模块,互相不影响, 但是也可以事项模块和模块之间的方法调用
    工厂模式: 工厂可以帮助我们实现调用的切换,或者实现一些中转的处理
    Observer: 观察者模式
    Mediator: 中介者模式
    Publish: 发布/订阅模式

  </p>
</body>
<script>
  // 单例模式 模块之间相互独立,同时也可以相互调用彼此的方法
  let moduleA = (function () {
    function bindHtml() {

    }
    return {
      bindHtml
    }
  })()
  let moduleB = (function () {
    function change() {

    }
    moduleA.bindHtml()
    return {
      change
    }
  })()
  // 单例模式 优化代码按顺序执行
  let SearchModule = (function () {
    let body = document.body
    function queryData() {
    }
    function getHtml() { }
    function handle() { }
    return {
      // init 相当于大脑,可以控制谁先执行,谁后执行;
      init: function () {
        queryData()
        handle()
        getHtml()
      }
    }
  })()


  // 工厂模式 输入原材料,得出不同的产品
  function factory(options) {
    options = options || {}
    let { type, payload } = options
    if (type === 'array') {
      return [1, 2]
    }
  }
  factory({ type: 'array', payload: 100 })
  factory({ type: 'object', payload: 200 })


  // 观察者模式
  class Observer {
    update() {
      // 消息触发到达,通知update执行
      console.log('消息到达11')
    }
  }
  class Demo {
    update(message) {
      console.log('消息到达22')

    }
  }
  // 专业管理目标
  class ObserverList {
    constructor() {
      this.observerList = []
    }
    add(observer) {
      this.observerList.push(observer)
      return this
    }
    remove(observer) {
      this.observerList = this.observerList.filter(ob => ob !== observer)
      return this
    }
    get(index) {
      return this.observerList[index]
    }
    count() {
      return this.observerList.length
    }
  }
  class Subject {
    observers = new ObserverList()
    add(observer) {
      this.observers.add(observer)
    }
    remove(observer) {
      this.observers.remove(observer)
    }
    notify() {
      for (let i = 0; i < this.observers.count(); i++) {
        let item = this.observers.get(i)
        item.update()
      }
    }
  }
  let o1 = new Observer()
  let d1 = new Demo()
  let sub = new Subject()
  sub.add(o1)
  sub.add(d1)
  setTimeout(() => {
    sub.notify('nnn你好~~欢迎大家')
  }, 2000)

  // 中介者模式
  let mediator = (function () {

    let topics = {}
    // 订阅: 订阅A组件中的某个方法
    let subsribe = function subsribe(topic, callback) {
      !topics[topic] ? topics[topic] = [] : null
      topics[topic].push({ context: this, callback })
    }
    // 发布: B组件中到某个阶段,可以通知之前订阅的方法执行
    let publish = function publish(topic, ...params) {
      if (!topics[topic]) return
      topics[topic].forEach(item => {
        let { callback, context } = item
        callback.call(context, ...params)
      })
    }
    return {
      subsribe,
      publish
    }
  })()

    // publish&subscribe Observer Mediator 这三个模式很像
    (function () {
      //自己创造的事件池
      let pond = []
      function subscribe(func) {
        if (!pond.includes(func)) {
          pond.push(func)
        }
        // 执行完移除
        return function unsubscribe() {
          pond = pond.filter(item => item !== func)
        }
      }
      subscribe.fire = function fire() {
        pond.forEach(item => {
          if(typeof item === 'function') {
            item(...arguments)
          }
        })
      }
      window.subscribe = subscribe
    })()

</script>

</html>